<!DOCTYPE html>
<!--[if IE 8]> 				 <html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->

<head>
  <meta charset="utf-8">
  <title>Async in C# and F#: Asynchronous gotchas in C#</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="This article is inspired by an MVP summit talk about common pitfalls in the C# asynchronous programming model. I look at a number of easy to make mistakes when writing asynchronous code in C# and demonstrate that most of them would not easily happen when using F#. ">
  <meta name="author" content="Tomas Petricek">

  <!-- Reference Foundation -->
  <link rel="stylesheet" href="http://tomasp.net/css/foundation.css">
  <script src="cjs/vendor/custom.modernizr.js"></script>

  <link rel="alternate" type="application/rss+xml" href="http://tomasp.net/rss.xml" title="RSS feed for Tomas Petricek's blog">
  <link rel="author" href="https://plus.google.com/109855146654605967051" />
    
  <!-- Reference custom CSS and tooltips -->
  <link type="text/css" rel="stylesheet" href="http://tomasp.net/custom/style.css" />
  <script type="text/javascript" src="http://tomasp.net/custom/tooltips.js"></script>
  <link type="text/css" rel="stylesheet" href="http://tomasp.net/custom/tooltips.css" />
</head>
<body>

   <header id="top-header">
    <div class="row">
      <div class="twelve columns">
        <h1><a href="http://tomasp.net/">Tomas Petricek's blog</a></h1>
        <p>Writing about practical F# coding and programming language research</p>
      </div>
    </div>
  </header>

  <header class="top-bar-header">
    <div class="contain-to-grid sticky">
    <nav class="top-bar">

    <ul class="title-area">
      <li class="name"><h1><a href="#"></a></h1></li>
      <li class="toggle-topbar menu-icon"><a href="#"><span>Menu</span></a></li>
    </ul>
    <section class="top-bar-section">
      <ul class="right">
        <li><a href="http://tomasp.net/blog/index.html">Blog</a></li>
        <li><a href="http://functional-programming.net">Trainings</a></li>
        <li><a href="http://functional-programming.net">Books</a></li>
        <li><a href="http://lanyrd.com/profile/tomasp">Talks</a></li>
        <li><a href="http://www.cl.cam.ac.uk/~tp322">Research & Teaching</a></li>
      </ul>
    </section>

    </nav></div>
  </header>
  
  
<div class="row">
	<div class="large-8 columns main-content">
    <content>
      

<h1>Async in C# and F#: Asynchronous gotchas in C#</h1>

<p>Back in February, I attended the annual MVP summit - an <a href="http://www.2013mvpsummit.com/about">event organized by Microsoft
for MVPs</a>. I used that opportunity to also visit
Boston and New York and do two F# talks and to record a <a href="http://channel9.msdn.com/posts/Tomas-Petricek-How-F-Learned-to-Stop-Worrying-and-Love-the-Data" title="Tomas Petricek (Channel 9): How F# Learned to Stop Worrying and Love the Data">Channel9 lecutre about type
providers</a>.
Despite all the <em>other activities</em> (often involving pubs, other F# people and long 
sleeping in the mornings), I also managed to come to some talks!</p>

<div style="margin-left:auto;margin-right:auto;width:379px;margin-top:10px;margin-bottom:20px;">
<img src="http://tomasp.net/articles/csharp-async-gotchas/async-clinic.png" style="width:379px;" />
</div>

<p>One (non-NDA) talk was the <a href="http://blogs.msdn.com/b/pfxteam/archive/2013/02/20/mvp-summit-presentation-on-async.aspx" title="Lucian Wischik, Stephen Toub: Async Clinic">Async Clinic</a> talk about the new <code>async</code> and <code>await</code> keywords 
in C# 5.0. Lucian and Stephen talked about common problems that C# developers face when 
writing asynchronous programs. In this blog post, I'll look at some of the problems from 
the F# perspective. The talk was quite lively, and someone recorded the reaction of the 
F# part of the audience as follows:</p>

<div style="margin-left:auto;margin-right:auto;width:379px;margin-top:10px;margin-bottom:20px;">
<a href="https://twitter.com/josefajardo/status/303998917027192832"><img src="http://tomasp.net/articles/csharp-async-gotchas/tweet.png" style="border-style:none" /></a>
</div>

<p>Why is that? It turns out that many of the common errors are not possible (or much less
likely) when using the F# asynchronous model (which has been around <a href="http://blogs.msdn.com/b/dsyme/archive/2007/07/27/f-1-9-2-7-released.aspx">since F# 1.9.2.7, which
was released in 2007</a>
and have been shipped with Visual Studio 2008).</p>

<h2>Gotcha #1: Async does not run asynchronously</h2>

<p>Let's go straight to the first tricky aspect of the C# asynchronous programming model. Take 
a look at the following example and figure out in what order will the strings be printed 
(I could not find the exact code shown at the talk, but I remember Lucian showing something
similar):</p>

<pre ><span class="kwrd">async</span> Task WorkThenWait() {
  Thread.Sleep(1000);
  Console.WriteLine(<span class="str">"work"</span>);
  await Task.Delay(1000);
}

<span class="kwrd">void</span> Demo() {
  <span class="kwrd">var</span> child = WorkThenWait();
  Console.WriteLine(<span class="str">"started"</span>);
  child.Wait();
  Console.WriteLine(<span class="str">"completed"</span>);
}</pre>

<p>If you guessed that it prints "started", "work" and "completed" then you're wrong. The code
prints "work", "started" and "completed", try it! What the author intended was to start 
the work (by calling <code>WorkThenWait</code>) and then await for the task later. The problem is that
<code>WorkThenWait</code> starts by doing some heavy computations (here, <code>Thread.Sleep</code>) and only after
that uses <code>await</code>.</p>

<p>In C#, the first part of the code in <code>async</code> method is executed synchronously (on the 
thread of the caller). You could fix that, for example, by adding <code>await Task.Yield()</code> at the 
beginning.</p>

<h3>Corresponding F# code</h3>

<p>This is not a problem in F#. When writing async code in F#, the entire code inside 
<code>async { ... }</code> block is all delayed and only started later (when you explicitly start it).
The above C# code corresponds to the following F#:</p>
<pre class="fssnip">
<span class="l"> 1: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fs1', 1)" onmouseover="showTip(event, 'fs1', 1)" class="i">workThenWait</span>() <span class="o">=</span> 
<span class="l"> 2: </span>  <span onmouseout="hideTip(event, 'fs2', 2)" onmouseover="showTip(event, 'fs2', 2)" class="i">Thread</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs3', 3)" onmouseover="showTip(event, 'fs3', 3)" class="i">Sleep</span>(<span class="n">1000</span>)
<span class="l"> 3: </span>  <span onmouseout="hideTip(event, 'fs4', 4)" onmouseover="showTip(event, 'fs4', 4)" class="i">printfn</span> <span class="s">&quot;</span><span class="s">work</span><span class="s"> </span><span class="s">done</span><span class="s">&quot;</span>
<span class="l"> 4: </span>  <span onmouseout="hideTip(event, 'fs5', 5)" onmouseover="showTip(event, 'fs5', 5)" class="i">async</span> { <span class="k">do!</span> <span onmouseout="hideTip(event, 'fs6', 6)" onmouseover="showTip(event, 'fs6', 6)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs7', 7)" onmouseover="showTip(event, 'fs7', 7)" class="i">Sleep</span>(<span class="n">1000</span>) }
<span class="l"> 5: </span>
<span class="l"> 6: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fs8', 8)" onmouseover="showTip(event, 'fs8', 8)" class="i">demo</span>() <span class="o">=</span> 
<span class="l"> 7: </span>  <span class="k">let</span> <span onmouseout="hideTip(event, 'fs9', 9)" onmouseover="showTip(event, 'fs9', 9)" class="i">work</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs1', 10)" onmouseover="showTip(event, 'fs1', 10)" class="i">workThenWait</span>() <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs6', 11)" onmouseover="showTip(event, 'fs6', 11)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs10', 12)" onmouseover="showTip(event, 'fs10', 12)" class="i">StartAsTask</span>
<span class="l"> 8: </span>  <span onmouseout="hideTip(event, 'fs4', 13)" onmouseover="showTip(event, 'fs4', 13)" class="i">printfn</span> <span class="s">&quot;</span><span class="s">started</span><span class="s">&quot;</span>
<span class="l"> 9: </span>  <span onmouseout="hideTip(event, 'fs9', 14)" onmouseover="showTip(event, 'fs9', 14)" class="i">work</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs11', 15)" onmouseover="showTip(event, 'fs11', 15)" class="i">Wait</span>()
<span class="l">10: </span>  <span onmouseout="hideTip(event, 'fs4', 16)" onmouseover="showTip(event, 'fs4', 16)" class="i">printfn</span> <span class="s">&quot;</span><span class="s">completed</span><span class="s">&quot;</span></pre>
<p>It is quite clear that the <code>workThenWait</code> function is not doing the work (<code>Thread.Sleep</code>) 
as part of the asynchronous computation and that it will be executed when the function
is called (and not when the async workflow is started).
The usual F# pattern is to wrap the entire function body in <code>async</code>. In F#, you
would write the following, which works as expected:</p>
<pre class="fssnip">
<span class="l">1: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fs1', 17)" onmouseover="showTip(event, 'fs1', 17)" class="i">workThenWait</span>() <span class="o">=</span> <span onmouseout="hideTip(event, 'fs5', 18)" onmouseover="showTip(event, 'fs5', 18)" class="i">async</span> { 
<span class="l">2: </span>  <span onmouseout="hideTip(event, 'fs2', 19)" onmouseover="showTip(event, 'fs2', 19)" class="i">Thread</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs3', 20)" onmouseover="showTip(event, 'fs3', 20)" class="i">Sleep</span>(<span class="n">1000</span>)
<span class="l">3: </span>  <span onmouseout="hideTip(event, 'fs4', 21)" onmouseover="showTip(event, 'fs4', 21)" class="i">printfn</span> <span class="s">&quot;</span><span class="s">work</span><span class="s"> </span><span class="s">done</span><span class="s">&quot;</span>
<span class="l">4: </span>  <span class="k">do!</span> <span onmouseout="hideTip(event, 'fs6', 22)" onmouseover="showTip(event, 'fs6', 22)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs7', 23)" onmouseover="showTip(event, 'fs7', 23)" class="i">Sleep</span>(<span class="n">1000</span>) }</pre>
<h2>Gotcha #2: Ignoring results</h2>

<p>Here is another gotcha in the C# asynchronous programming model (this one is taken directly
from Lucian's slides). Guess what happens when you run the following asynchronous method:</p>

<pre ><span class="kwrd">async</span> Task Handler() {
  Console.WriteLine(<span class="str">"Before"</span>);
  Task.Delay(1000);
  Console.WriteLine(<span class="str">"After"</span>);
}</pre>

<p>Were you expecting that it prints "Before", waits 1 second and then prints "After"? Wrong!
It prints both messages immediately without any waiting in between. The problem is that
<code>Task.Delay</code> <em>returns</em> a <code>Task</code> and we forgot to await until it completes using <code>await</code>.</p>

<h3>Corresponding F# code</h3>

<p>Again, you would probably not hit this issue in F#. You can surely write code that calls
<code>Async.Sleep</code> and ignores the returned <code>Async&lt;unit&gt;</code>:</p>
<pre class="fssnip">
<span class="l">1: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fs12', 24)" onmouseover="showTip(event, 'fs12', 24)" class="i">handler</span>() <span class="o">=</span> <span onmouseout="hideTip(event, 'fs5', 25)" onmouseover="showTip(event, 'fs5', 25)" class="i">async</span> {
<span class="l">2: </span>  <span onmouseout="hideTip(event, 'fs4', 26)" onmouseover="showTip(event, 'fs4', 26)" class="i">printfn</span> <span class="s">&quot;</span><span class="s">Before</span><span class="s">&quot;</span>
<span class="l">3: </span>  <span onmouseout="hideTip(event, 'fs6', 27)" onmouseover="showTip(event, 'fs6', 27)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs7', 28)" onmouseover="showTip(event, 'fs7', 28)" class="i">Sleep</span>(<span class="n">1000</span>)
<span class="l">4: </span>  <span onmouseout="hideTip(event, 'fs4', 29)" onmouseover="showTip(event, 'fs4', 29)" class="i">printfn</span> <span class="s">&quot;</span><span class="s">After</span><span class="s">&quot;</span> }</pre>
<p>If you paste the code in Visual Studio, MonoDevelop or Try F#, you get an immediate 
feedback with a warning saying that:</p>

<blockquote>
  <p>warning FS0020: This expression should have type <code>unit</code>, but has type 
<code>Async&lt;unit&gt;</code>. Use <code>ignore</code> to discard the result of the expression, or 
<code>let</code> to bind the result to a name.</p>
</blockquote>

<p>You can still compile the code and run it, but if you read the warning, you'll see
that the expression returns <code>Async&lt;unit&gt;</code> and you need to await it using <code>do!</code>:</p>
<pre class="fssnip">
<span class="l">1: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fs12', 30)" onmouseover="showTip(event, 'fs12', 30)" class="i">handler</span>() <span class="o">=</span> <span onmouseout="hideTip(event, 'fs5', 31)" onmouseover="showTip(event, 'fs5', 31)" class="i">async</span> {
<span class="l">2: </span>  <span onmouseout="hideTip(event, 'fs4', 32)" onmouseover="showTip(event, 'fs4', 32)" class="i">printfn</span> <span class="s">&quot;</span><span class="s">Before</span><span class="s">&quot;</span>
<span class="l">3: </span>  <span class="k">do!</span> <span onmouseout="hideTip(event, 'fs6', 33)" onmouseover="showTip(event, 'fs6', 33)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs7', 34)" onmouseover="showTip(event, 'fs7', 34)" class="i">Sleep</span>(<span class="n">1000</span>)
<span class="l">4: </span>  <span onmouseout="hideTip(event, 'fs4', 35)" onmouseover="showTip(event, 'fs4', 35)" class="i">printfn</span> <span class="s">&quot;</span><span class="s">After</span><span class="s">&quot;</span> }</pre>
<h2>Gotcha #3: Async void methods</h2>

<p>Quite a lot of time in the talk was dedicated to <em>async void</em> methods. If you write
<code>async void Foo() { ... }</code>, then the C# compiler generates a method that returns
<code>void</code>. Under the cover, it creates and starts a task. This means that you have no way
of telling when the work has actually happened.</p>

<p>Here is a recommendation on the <em>async void</em> pattern from the talk:</p>

<div style="margin-left:auto;margin-right:auto;width:379px;margin-top:10px;margin-bottom:20px;">
<img src="http://tomasp.net/articles/csharp-async-gotchas/async-void.png" style="width:379px;" />
</div>

<p>To be fair - async void methods <em>can</em> be useful when you're writing an event handler.
Event handlers should return <code>void</code> and they often start some work that continues in 
background. But I do not think this is really useful in the world of MVVM - but it 
surely makes nice demos at conference talks.</p>

<p>Let me demonstrate the problem using a snippet from <a href="http://msdn.microsoft.com/en-us/magazine/jj991977.aspx" title="Stephen Cleary: Best Practices in Asynchronous Programming">MSDN Magazine article</a>
on asynchronous programming in C#:</p>

<pre ><span class="kwrd">async</span> <span class="kwrd">void</span> ThrowExceptionAsync() {
  <span class="kwrd">throw</span> <span class="kwrd">new</span> InvalidOperationException();
}

<span class="kwrd">public</span> <span class="kwrd">void</span> CallThrowExceptionAsync() {
  <span class="kwrd">try</span> {
    ThrowExceptionAsync();
  } <span class="kwrd">catch</span> (Exception) {
    Console.WriteLine(<span class="str">"Failed"</span>);
  }
}</pre>

<p>Do you think that the code prints "Failed"? I suppose you already understood the style
of this blog post... Indeed, the exception is not handled because <code>ThrowExceptionAsync</code>
starts the work and returns immediately (and the exception happens somewhere on a background
thread).</p>

<h3>Corresponding F# code</h3>

<p>So, if you should not be using a programming language feature, then it is probably 
better not to include the feature in the first place. F# does not let you write
<em>async void</em> functions - when you wrap function body in the <code>async { ... }</code> block,
its return type will be <code>Async&lt;T&gt;</code>. If you used type annotations and demanded <code>unit</code>, 
you would get a type mismatch.</p>

<p>You can still write code that corresponds to the above C# using <code>Async.Start</code>:</p>
<pre class="fssnip">
<span class="l">1: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fs13', 36)" onmouseover="showTip(event, 'fs13', 36)" class="i">throwExceptionAsync</span>() <span class="o">=</span> <span onmouseout="hideTip(event, 'fs5', 37)" onmouseover="showTip(event, 'fs5', 37)" class="i">async</span> {
<span class="l">2: </span>  <span onmouseout="hideTip(event, 'fs14', 38)" onmouseover="showTip(event, 'fs14', 38)" class="i">raise</span> <span class="o">&lt;|</span> <span class="k">new</span> <span onmouseout="hideTip(event, 'fs15', 39)" onmouseover="showTip(event, 'fs15', 39)" class="i">InvalidOperationException</span>() }
<span class="l">3: </span>
<span class="l">4: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fs16', 40)" onmouseover="showTip(event, 'fs16', 40)" class="i">callThrowExceptionAsync</span>() <span class="o">=</span> 
<span class="l">5: </span>  <span class="k">try</span>
<span class="l">6: </span>    <span onmouseout="hideTip(event, 'fs13', 41)" onmouseover="showTip(event, 'fs13', 41)" class="i">throwExceptionAsync</span>()
<span class="l">7: </span>    <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs6', 42)" onmouseover="showTip(event, 'fs6', 42)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs17', 43)" onmouseover="showTip(event, 'fs17', 43)" class="i">Start</span>
<span class="l">8: </span>  <span class="k">with</span> <span onmouseout="hideTip(event, 'fs18', 44)" onmouseover="showTip(event, 'fs18', 44)" class="i">e</span> <span class="k">-&gt;</span>
<span class="l">9: </span>    <span onmouseout="hideTip(event, 'fs4', 45)" onmouseover="showTip(event, 'fs4', 45)" class="i">printfn</span> <span class="s">&quot;</span><span class="s">Failed</span><span class="s">&quot;</span></pre>
<p>This will also not handle the exception. But it is more obvious what is going on because
we had to write <code>Async.Start</code> explicitly. If we did not write it, we would get a 
warning saying that the function returns <code>Async&lt;void&gt;</code> and we are ignoring the result
(the same as in the earlier section "Ignoring results").</p>

<h2>Gotcha #4: Async void lambda functions</h2>

<p>Even trickier case is when you pass asynchronous lambda function to some method as a 
delegate. In this case, the C# compiler infers the type of method from the delegate type.
If you use the <code>Action</code> delegate (or similar), then the compiler produces async void
function (which starts the work and returns <code>void</code>). If you use the <code>Func&lt;Task&gt;</code> delegate,
the compiler generates a function that returns <code>Task</code>.</p>

<p>Here is a sample from Lucian's slides. Does the following (perfectly valid) code finish 
in 1 second (after all the tasks finish sleeping), or does it finish immediately?</p>

<pre >Parallel.For(0, 10, <span class="kwrd">async</span> i =&gt; {
  await Task.Delay(1000);
});</pre>

<p>You cannot know that, unless you know that <code>For</code> only has overloads that take <code>Action</code>
delegates - and thus the lambda function will always be compiled as async void. This
also means that adding such (maybe useful?) overload would be a breaking change.</p>

<h3>Corresponding F# code</h3>

<p>The F# language does not have special "async lambda functions", but you can surely
write a lambda function that returns asynchronous computation. The return type of such
function will be <code>Async&lt;T&gt;</code> and so it cannot be passed as an argument to methods that
expect void-returning delegate. The following F# code does not compile:</p>
<pre class="fssnip">
<span class="l">1: </span><span onmouseout="hideTip(event, 'fs19', 46)" onmouseover="showTip(event, 'fs19', 46)" class="i">Parallel</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs20', 47)" onmouseover="showTip(event, 'fs20', 47)" class="i">For</span>(<span class="n">0</span>, <span class="n">10</span>, <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs21', 48)" onmouseover="showTip(event, 'fs21', 48)" class="i">i</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs5', 49)" onmouseover="showTip(event, 'fs5', 49)" class="i">async</span> {
<span class="l">2: </span>  <span class="k">do!</span> <span onmouseout="hideTip(event, 'fs6', 50)" onmouseover="showTip(event, 'fs6', 50)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs7', 51)" onmouseover="showTip(event, 'fs7', 51)" class="i">Sleep</span>(<span class="n">1000</span>) 
<span class="l">3: </span>})</pre>
<p>The error message simply says that a function type <code>int -&gt; Async&lt;unit&gt;</code> is not 
compatible with the <code>Action&lt;int&gt;</code> delegate (which would be <code>int -&gt; unit</code> in F#):</p>

<blockquote>
  <p>error FS0041: No overloads match for method <code>For</code>. The available overloads 
are shown below (or in the Error List window).</p>
</blockquote>

<p>To get the same behaviour as the above C# code, we need to explicitly start the
work. If you want to start asynchronous workflow in the background, then you can
easily do that using <code>Async.Start</code> (which takes a unit-returning asynchronous
computation, schedules it and returns <code>unit</code>):</p>
<pre class="fssnip">
<span class="l">1: </span><span onmouseout="hideTip(event, 'fs19', 52)" onmouseover="showTip(event, 'fs19', 52)" class="i">Parallel</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs20', 53)" onmouseover="showTip(event, 'fs20', 53)" class="i">For</span>(<span class="n">0</span>, <span class="n">10</span>, <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs22', 54)" onmouseover="showTip(event, 'fs22', 54)" class="i">i</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs6', 55)" onmouseover="showTip(event, 'fs6', 55)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs17', 56)" onmouseover="showTip(event, 'fs17', 56)" class="i">Start</span>(<span onmouseout="hideTip(event, 'fs5', 57)" onmouseover="showTip(event, 'fs5', 57)" class="i">async</span> {
<span class="l">2: </span>  <span class="k">do!</span> <span onmouseout="hideTip(event, 'fs6', 58)" onmouseover="showTip(event, 'fs6', 58)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs7', 59)" onmouseover="showTip(event, 'fs7', 59)" class="i">Sleep</span>(<span class="n">1000</span>) 
<span class="l">3: </span>}))</pre>
<p>You can certainly write this, but it is quite easy to see what is going on. 
It is also not difficult to see that we are wasting resources, because the point
of <code>Parallel.For</code> is that it runs <em>CPU-intensive</em> computations (which are typically
synchronous functions) in parallel.</p>

<h2>Gotcha #5: Nesting of tasks</h2>

<p>I think that Lucian included the next one just to test the mental-compilation
skills of the people in the audience, but here it is. The question is, does the
following code wait 1 second between the two prints?</p>

<pre >Console.WriteLine(<span class="str">"Before"</span>);
await Task.Factory.StartNew(
  <span class="kwrd">async</span> () =&gt; { await Task.Delay(1000); });
Console.WriteLine(<span class="str">"After"</span>);</pre>

<p>Again, quite unexpectedly, this does not actually wait between the two writes.
How is that possible? The <code>StartNew</code> method takes a delegate and returns a <code>Task&lt;T&gt;</code>
where <code>T</code> is the type returned by the delegate. In the above case, the delegate
returns <code>Task</code>, so we get <code>Task&lt;Task&gt;</code> as the result. Using <code>await</code> waits only
for the completion of the outer task (which immediately returns the inner task)
and the inner task is then ignored.</p>

<p>In C#, you can fix this by using <code>Task.Run</code> instead of <code>StartNew</code> (or by dropping
the <code>async</code> and <code>await</code> in the lambda function).</p>

<p>Can we write something similar in F#? We can create a task that will return
<code>Async&lt;unit&gt;</code> using <code>Task.Factory.StartNew</code> and lambda function that returns an
async block. To await the task, we will need to convert it to asynchronous workflo
using <code>Async.AwaitTask</code>. This means we will get <code>Async&lt;Async&lt;unit&gt;&gt;</code>:</p>
<pre class="fssnip">
<span class="l">1: </span><span onmouseout="hideTip(event, 'fs5', 60)" onmouseover="showTip(event, 'fs5', 60)" class="i">async</span> {
<span class="l">2: </span>  <span class="k">do!</span> <span onmouseout="hideTip(event, 'fs23', 61)" onmouseover="showTip(event, 'fs23', 61)" class="i">Task</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs24', 62)" onmouseover="showTip(event, 'fs24', 62)" class="i">Factory</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs25', 63)" onmouseover="showTip(event, 'fs25', 63)" class="i">StartNew</span>(<span class="k">fun</span> () <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs5', 64)" onmouseover="showTip(event, 'fs5', 64)" class="i">async</span> { 
<span class="l">3: </span>    <span class="k">do!</span> <span onmouseout="hideTip(event, 'fs6', 65)" onmouseover="showTip(event, 'fs6', 65)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs7', 66)" onmouseover="showTip(event, 'fs7', 66)" class="i">Sleep</span>(<span class="n">1000</span>) }) <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs6', 67)" onmouseover="showTip(event, 'fs6', 67)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs26', 68)" onmouseover="showTip(event, 'fs26', 68)" class="i">AwaitTask</span> }</pre>
<p>Again, this code does not compile. The problem is that the <code>do!</code> keyword requires
<code>Async&lt;unit&gt;</code> on the right-hand side, but it actually gets <code>Async&lt;Async&lt;unit&gt;&gt;</code>. In
other words, we cannot simply ignore the result. We need to explicitly do something
with it (we could use <code>Async.Ignore</code> to replicate the C# behaviour). The error 
message might not be as clear as the earlier messages, but you can get the idea:</p>

<blockquote>
  <p>error FS0001: This expression was expected to have type <code>Async&lt;unit&gt;</code> 
but here has type <code>unit</code></p>
</blockquote>

<h2>Gotcha #6: Not running asynchronously</h2>

<p>Here is another problematic code snippet from Lucian's slide. This time, the problem
is quite simple. The following snippet defines an asynchronous method <code>FooAsync</code> and
calls it from a <code>Handler</code>, but the code does not run asynchronously:</p>

<pre ><span class="kwrd">async</span> Task FooAsync() {
  await Task.Delay(1000);
}
<span class="kwrd">void</span> Handler() {
  FooAsync().Wait();
}</pre>

<p>It is not too difficult to spot the issue - we are calling <code>FooAsync().Wait()</code>. This 
means that we create a task and then, using <code>Wait</code>, block until it completes. Simply
removing <code>Wait</code> fixes the problem, because we just want to start the task.</p>

<p>You can write the same code in F#, but asynchronous workflows do not use .NET Tasks
(which were originally designed for CPU-bound computations) and instead uses F#
<code>Async&lt;T&gt;</code> which does not come with <code>Wait</code>. This means you have to write:</p>
<pre class="fssnip">
<span class="l">1: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fs27', 69)" onmouseover="showTip(event, 'fs27', 69)" class="i">fooAsync</span>() <span class="o">=</span> <span onmouseout="hideTip(event, 'fs5', 70)" onmouseover="showTip(event, 'fs5', 70)" class="i">async</span> {
<span class="l">2: </span>  <span class="k">do!</span> <span onmouseout="hideTip(event, 'fs6', 71)" onmouseover="showTip(event, 'fs6', 71)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs7', 72)" onmouseover="showTip(event, 'fs7', 72)" class="i">Sleep</span>(<span class="n">1000</span>) }
<span class="l">3: </span><span class="k">let</span> <span onmouseout="hideTip(event, 'fs28', 73)" onmouseover="showTip(event, 'fs28', 73)" class="i">handler</span>() <span class="o">=</span> 
<span class="l">4: </span>  <span onmouseout="hideTip(event, 'fs27', 74)" onmouseover="showTip(event, 'fs27', 74)" class="i">fooAsync</span>() <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs6', 75)" onmouseover="showTip(event, 'fs6', 75)" class="i">Async</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs29', 76)" onmouseover="showTip(event, 'fs29', 76)" class="i">RunSynchronously</span></pre>
<p>You could certainly write such code by accident, but if you face a problem that it does
not run <em>asynchronously</em>, you can easily spot that the code calls
<code>RunSynchronously</code> and so the work is done - as the name suggests - <em>synchronously</em>.</p>

<h2>Summary</h2>

<p>In this article, I looked at six cases where the C# asynchronous programming model
behaves in an unexpected way. Most of them were based on a talk by Lucian and Stephen
at the MVP summit, so thanks to both of them for sharing an interesting list of common
pitfalls!</p>

<p>I tried to find the closest corresponding code snippet in F#, using asynchronous workflows.
In most of the cases, the F# compiler reports a warning or an error - or the programming
model does not have a (direct) way to express the same code. I think this supports the 
claim that I made <a href="http://tomasp.net/blog/csharp-fsharp-async-intro.aspx" title="Tomas Petricek: Asynchronous C# and F# (I.): Simultaneous introduction">in an earlier blog post</a> that <em>"The F# programming model definitely 
feels more suitable for functional (declarative) programming languages. I also think that it 
makes it easier to reason about what is going on"</em>.</p>

<p>Finally, this article should not be understood as a devastating criticism of C# async :-). I can 
fully understand why the C# design follows the principles it follows - for C#, it makes
sense to use <code>Task&lt;T&gt;</code> (instead of separate <code>Async&lt;T&gt;</code>), which has a number of implications.
And I can understand the reasoning behind other decisions too - it is likely the best way
to integrate asynchronous programming in C#. But at the same time, I think F# does a better 
job - partly because of the composability, but more importantly because of greate additions
like the <a href="http://www.developerfusion.com/article/139804/an-introduction-to-f-agents" title="Tomas Petricek: An Introduction To F# Agents">F# agents</a>. Also, F# async has its problems too (the most common gotcha
is that tail-recursive functions must use <code>return!</code> instead of <code>do!</code> to avoid leaks), but 
that is a topic for a separate blog post.</p>

<div class="tip" id="fs1">val workThenWait : unit -&gt; Async&lt;unit&gt;<br /><br />Full name: Csharp-async-gotchas.aspx_.workThenWait</div>
<div class="tip" id="fs2">Multiple items<br />type Thread =<br />&#160;&#160;inherit CriticalFinalizerObject<br />&#160;&#160;new : start:ThreadStart -&gt; Thread + 3 overloads<br />&#160;&#160;member Abort : unit -&gt; unit + 1 overload<br />&#160;&#160;member ApartmentState : ApartmentState with get, set<br />&#160;&#160;member CurrentCulture : CultureInfo with get, set<br />&#160;&#160;member CurrentUICulture : CultureInfo with get, set<br />&#160;&#160;member DisableComObjectEagerCleanup : unit -&gt; unit<br />&#160;&#160;member ExecutionContext : ExecutionContext<br />&#160;&#160;member GetApartmentState : unit -&gt; ApartmentState<br />&#160;&#160;member GetCompressedStack : unit -&gt; CompressedStack<br />&#160;&#160;member GetHashCode : unit -&gt; int<br />&#160;&#160;...<br /><br />Full name: System.Threading.Thread<br /><br />--------------------<br />Thread(start: ThreadStart) : unit<br />Thread(start: ParameterizedThreadStart) : unit<br />Thread(start: ThreadStart, maxStackSize: int) : unit<br />Thread(start: ParameterizedThreadStart, maxStackSize: int) : unit</div>
<div class="tip" id="fs3">Thread.Sleep(timeout: TimeSpan) : unit<br />Thread.Sleep(millisecondsTimeout: int) : unit</div>
<div class="tip" id="fs4">val printfn : format:Printf.TextWriterFormat&lt;&#39;T&gt; -&gt; &#39;T<br /><br />Full name: Microsoft.FSharp.Core.ExtraTopLevelOperators.printfn</div>
<div class="tip" id="fs5">val async : AsyncBuilder<br /><br />Full name: Microsoft.FSharp.Core.ExtraTopLevelOperators.async</div>
<div class="tip" id="fs6">Multiple items<br />type Async<br />static member AsBeginEnd : computation:(&#39;Arg -&gt; Async&lt;&#39;T&gt;) -&gt; (&#39;Arg * AsyncCallback * obj -&gt; IAsyncResult) * (IAsyncResult -&gt; &#39;T) * (IAsyncResult -&gt; unit)<br />static member AwaitEvent : event:IEvent&lt;&#39;Del,&#39;T&gt; * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt; (requires delegate and &#39;Del :&gt; Delegate)<br />static member AwaitIAsyncResult : iar:IAsyncResult * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;<br />static member AwaitTask : task:Task&lt;&#39;T&gt; -&gt; Async&lt;&#39;T&gt;<br />static member AwaitWaitHandle : waitHandle:WaitHandle * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;<br />static member CancelDefaultToken : unit -&gt; unit<br />static member Catch : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;Choice&lt;&#39;T,exn&gt;&gt;<br />static member FromBeginEnd : beginAction:(AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromBeginEnd : arg:&#39;Arg1 * beginAction:(&#39;Arg1 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromBeginEnd : arg1:&#39;Arg1 * arg2:&#39;Arg2 * beginAction:(&#39;Arg1 * &#39;Arg2 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromBeginEnd : arg1:&#39;Arg1 * arg2:&#39;Arg2 * arg3:&#39;Arg3 * beginAction:(&#39;Arg1 * &#39;Arg2 * &#39;Arg3 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromContinuations : callback:((&#39;T -&gt; unit) * (exn -&gt; unit) * (OperationCanceledException -&gt; unit) -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member Ignore : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;unit&gt;<br />static member OnCancel : interruption:(unit -&gt; unit) -&gt; Async&lt;IDisposable&gt;<br />static member Parallel : computations:seq&lt;Async&lt;&#39;T&gt;&gt; -&gt; Async&lt;&#39;T []&gt;<br />static member RunSynchronously : computation:Async&lt;&#39;T&gt; * ?timeout:int * ?cancellationToken:CancellationToken -&gt; &#39;T<br />static member Sleep : millisecondsDueTime:int -&gt; Async&lt;unit&gt;<br />static member Start : computation:Async&lt;unit&gt; * ?cancellationToken:CancellationToken -&gt; unit<br />static member StartAsTask : computation:Async&lt;&#39;T&gt; * ?taskCreationOptions:TaskCreationOptions * ?cancellationToken:CancellationToken -&gt; Task&lt;&#39;T&gt;<br />static member StartChild : computation:Async&lt;&#39;T&gt; * ?millisecondsTimeout:int -&gt; Async&lt;Async&lt;&#39;T&gt;&gt;<br />static member StartChildAsTask : computation:Async&lt;&#39;T&gt; * ?taskCreationOptions:TaskCreationOptions -&gt; Async&lt;Task&lt;&#39;T&gt;&gt;<br />static member StartImmediate : computation:Async&lt;unit&gt; * ?cancellationToken:CancellationToken -&gt; unit<br />static member StartWithContinuations : computation:Async&lt;&#39;T&gt; * continuation:(&#39;T -&gt; unit) * exceptionContinuation:(exn -&gt; unit) * cancellationContinuation:(OperationCanceledException -&gt; unit) * ?cancellationToken:CancellationToken -&gt; unit<br />static member SwitchToContext : syncContext:SynchronizationContext -&gt; Async&lt;unit&gt;<br />static member SwitchToNewThread : unit -&gt; Async&lt;unit&gt;<br />static member SwitchToThreadPool : unit -&gt; Async&lt;unit&gt;<br />static member TryCancelled : computation:Async&lt;&#39;T&gt; * compensation:(OperationCanceledException -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member CancellationToken : Async&lt;CancellationToken&gt;<br />static member DefaultCancellationToken : CancellationToken<br /><br />Full name: Microsoft.FSharp.Control.Async<br /><br />--------------------<br />type Async&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Control.Async&lt;_&gt;</div>
<div class="tip" id="fs7">static member Async.Sleep : millisecondsDueTime:int -&gt; Async&lt;unit&gt;</div>
<div class="tip" id="fs8">val demo : unit -&gt; unit<br /><br />Full name: Csharp-async-gotchas.aspx_.demo</div>
<div class="tip" id="fs9">val work : Task&lt;unit&gt;</div>
<div class="tip" id="fs10">static member Async.StartAsTask : computation:Async&lt;&#39;T&gt; * ?taskCreationOptions:TaskCreationOptions * ?cancellationToken:CancellationToken -&gt; Task&lt;&#39;T&gt;</div>
<div class="tip" id="fs11">Task.Wait() : unit<br />Task.Wait(millisecondsTimeout: int) : bool<br />Task.Wait(cancellationToken: CancellationToken) : unit<br />Task.Wait(timeout: TimeSpan) : bool<br />Task.Wait(millisecondsTimeout: int, cancellationToken: CancellationToken) : bool</div>
<div class="tip" id="fs12">val handler : unit -&gt; Async&lt;unit&gt;<br /><br />Full name: Csharp-async-gotchas.aspx_.handler</div>
<div class="tip" id="fs13">val throwExceptionAsync : unit -&gt; Async&lt;unit&gt;<br /><br />Full name: Csharp-async-gotchas.aspx_.throwExceptionAsync</div>
<div class="tip" id="fs14">val raise : exn:Exception -&gt; &#39;T<br /><br />Full name: Microsoft.FSharp.Core.Operators.raise</div>
<div class="tip" id="fs15">Multiple items<br />type InvalidOperationException =<br />&#160;&#160;inherit SystemException<br />&#160;&#160;new : unit -&gt; InvalidOperationException + 2 overloads<br /><br />Full name: System.InvalidOperationException<br /><br />--------------------<br />InvalidOperationException() : unit<br />InvalidOperationException(message: string) : unit<br />InvalidOperationException(message: string, innerException: exn) : unit</div>
<div class="tip" id="fs16">val callThrowExceptionAsync : unit -&gt; unit<br /><br />Full name: Csharp-async-gotchas.aspx_.callThrowExceptionAsync</div>
<div class="tip" id="fs17">static member Async.Start : computation:Async&lt;unit&gt; * ?cancellationToken:CancellationToken -&gt; unit</div>
<div class="tip" id="fs18">val e : exn</div>
<div class="tip" id="fs19">type Parallel =<br />&#160;&#160;static member For : fromInclusive:int * toExclusive:int * body:Action&lt;int&gt; -&gt; ParallelLoopResult + 11 overloads<br />&#160;&#160;static member ForEach&lt;&#39;TSource&gt; : source:IEnumerable&lt;&#39;TSource&gt; * body:Action&lt;&#39;TSource&gt; -&gt; ParallelLoopResult + 19 overloads<br />&#160;&#160;static member Invoke : params actions:Action[] -&gt; unit + 1 overload<br /><br />Full name: System.Threading.Tasks.Parallel</div>
<div class="tip" id="fs20">Parallel.For(fromInclusive: int64, toExclusive: int64, body: Action&lt;int64,ParallelLoopState&gt;) : ParallelLoopResult<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />Parallel.For(fromInclusive: int, toExclusive: int, body: Action&lt;int,ParallelLoopState&gt;) : ParallelLoopResult<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />Parallel.For(fromInclusive: int64, toExclusive: int64, body: Action&lt;int64&gt;) : ParallelLoopResult<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />Parallel.For(fromInclusive: int, toExclusive: int, body: Action&lt;int&gt;) : ParallelLoopResult<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />Parallel.For(fromInclusive: int64, toExclusive: int64, parallelOptions: ParallelOptions, body: Action&lt;int64,ParallelLoopState&gt;) : ParallelLoopResult<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />Parallel.For(fromInclusive: int, toExclusive: int, parallelOptions: ParallelOptions, body: Action&lt;int,ParallelLoopState&gt;) : ParallelLoopResult<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />Parallel.For(fromInclusive: int64, toExclusive: int64, parallelOptions: ParallelOptions, body: Action&lt;int64&gt;) : ParallelLoopResult<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />Parallel.For(fromInclusive: int, toExclusive: int, parallelOptions: ParallelOptions, body: Action&lt;int&gt;) : ParallelLoopResult<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />Parallel.For&lt;&#39;TLocal&gt;(fromInclusive: int64, toExclusive: int64, localInit: Func&lt;&#39;TLocal&gt;, body: Func&lt;int64,ParallelLoopState,&#39;TLocal,&#39;TLocal&gt;, localFinally: Action&lt;&#39;TLocal&gt;) : ParallelLoopResult<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />Parallel.For&lt;&#39;TLocal&gt;(fromInclusive: int, toExclusive: int, localInit: Func&lt;&#39;TLocal&gt;, body: Func&lt;int,ParallelLoopState,&#39;TLocal,&#39;TLocal&gt;, localFinally: Action&lt;&#39;TLocal&gt;) : ParallelLoopResult<br />&#160;&#160;&#160;<em>(+0 other overloads)</em></div>
<div class="tip" id="fs21">val i : &#39;a</div>
<div class="tip" id="fs22">val i : int</div>
<div class="tip" id="fs23">Multiple items<br />type Task =<br />&#160;&#160;new : action:Action -&gt; Task + 7 overloads<br />&#160;&#160;member AsyncState : obj<br />&#160;&#160;member ConfigureAwait : continueOnCapturedContext:bool -&gt; ConfiguredTaskAwaitable<br />&#160;&#160;member ContinueWith : continuationAction:Action&lt;Task&gt; -&gt; Task + 19 overloads<br />&#160;&#160;member CreationOptions : TaskCreationOptions<br />&#160;&#160;member Dispose : unit -&gt; unit<br />&#160;&#160;member Exception : AggregateException<br />&#160;&#160;member GetAwaiter : unit -&gt; TaskAwaiter<br />&#160;&#160;member Id : int<br />&#160;&#160;member IsCanceled : bool<br />&#160;&#160;...<br /><br />Full name: System.Threading.Tasks.Task<br /><br />--------------------<br />type Task&lt;&#39;TResult&gt; =<br />&#160;&#160;inherit Task<br />&#160;&#160;new : function:Func&lt;&#39;TResult&gt; -&gt; Task&lt;&#39;TResult&gt; + 7 overloads<br />&#160;&#160;member ConfigureAwait : continueOnCapturedContext:bool -&gt; ConfiguredTaskAwaitable&lt;&#39;TResult&gt;<br />&#160;&#160;member ContinueWith : continuationAction:Action&lt;Task&lt;&#39;TResult&gt;&gt; -&gt; Task + 19 overloads<br />&#160;&#160;member GetAwaiter : unit -&gt; TaskAwaiter&lt;&#39;TResult&gt;<br />&#160;&#160;member Result : &#39;TResult<br />&#160;&#160;static member Factory : TaskFactory&lt;&#39;TResult&gt;<br /><br />Full name: System.Threading.Tasks.Task&lt;_&gt;<br /><br />--------------------<br />Task(action: Action) : unit<br />Task(action: Action, cancellationToken: CancellationToken) : unit<br />Task(action: Action, creationOptions: TaskCreationOptions) : unit<br />Task(action: Action&lt;obj&gt;, state: obj) : unit<br />Task(action: Action, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions) : unit<br />Task(action: Action&lt;obj&gt;, state: obj, cancellationToken: CancellationToken) : unit<br />Task(action: Action&lt;obj&gt;, state: obj, creationOptions: TaskCreationOptions) : unit<br />Task(action: Action&lt;obj&gt;, state: obj, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions) : unit<br /><br />--------------------<br />Task(function: Func&lt;&#39;TResult&gt;) : unit<br />Task(function: Func&lt;&#39;TResult&gt;, cancellationToken: CancellationToken) : unit<br />Task(function: Func&lt;&#39;TResult&gt;, creationOptions: TaskCreationOptions) : unit<br />Task(function: Func&lt;obj,&#39;TResult&gt;, state: obj) : unit<br />Task(function: Func&lt;&#39;TResult&gt;, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions) : unit<br />Task(function: Func&lt;obj,&#39;TResult&gt;, state: obj, cancellationToken: CancellationToken) : unit<br />Task(function: Func&lt;obj,&#39;TResult&gt;, state: obj, creationOptions: TaskCreationOptions) : unit<br />Task(function: Func&lt;obj,&#39;TResult&gt;, state: obj, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions) : unit</div>
<div class="tip" id="fs24">Multiple items<br />property Task.Factory: TaskFactory<br /><br />--------------------<br />property Task.Factory: TaskFactory&lt;&#39;TResult&gt;</div>
<div class="tip" id="fs25">Multiple items<br />TaskFactory.StartNew&lt;&#39;TResult&gt;(function: Func&lt;&#39;TResult&gt;) : Task&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />TaskFactory.StartNew(action: Action) : Task<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />TaskFactory.StartNew&lt;&#39;TResult&gt;(function: Func&lt;obj,&#39;TResult&gt;, state: obj) : Task&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />TaskFactory.StartNew&lt;&#39;TResult&gt;(function: Func&lt;&#39;TResult&gt;, creationOptions: TaskCreationOptions) : Task&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />TaskFactory.StartNew&lt;&#39;TResult&gt;(function: Func&lt;&#39;TResult&gt;, cancellationToken: CancellationToken) : Task&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />TaskFactory.StartNew(action: Action&lt;obj&gt;, state: obj) : Task<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />TaskFactory.StartNew(action: Action, creationOptions: TaskCreationOptions) : Task<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />TaskFactory.StartNew(action: Action, cancellationToken: CancellationToken) : Task<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />TaskFactory.StartNew&lt;&#39;TResult&gt;(function: Func&lt;obj,&#39;TResult&gt;, state: obj, creationOptions: TaskCreationOptions) : Task&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />TaskFactory.StartNew&lt;&#39;TResult&gt;(function: Func&lt;obj,&#39;TResult&gt;, state: obj, cancellationToken: CancellationToken) : Task&lt;&#39;TResult&gt;<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br /><br />--------------------<br />TaskFactory.StartNew(function: Func&lt;&#39;TResult&gt;) : Task&lt;&#39;TResult&gt;<br />TaskFactory.StartNew(function: Func&lt;obj,&#39;TResult&gt;, state: obj) : Task&lt;&#39;TResult&gt;<br />TaskFactory.StartNew(function: Func&lt;&#39;TResult&gt;, creationOptions: TaskCreationOptions) : Task&lt;&#39;TResult&gt;<br />TaskFactory.StartNew(function: Func&lt;&#39;TResult&gt;, cancellationToken: CancellationToken) : Task&lt;&#39;TResult&gt;<br />TaskFactory.StartNew(function: Func&lt;obj,&#39;TResult&gt;, state: obj, creationOptions: TaskCreationOptions) : Task&lt;&#39;TResult&gt;<br />TaskFactory.StartNew(function: Func&lt;obj,&#39;TResult&gt;, state: obj, cancellationToken: CancellationToken) : Task&lt;&#39;TResult&gt;<br />TaskFactory.StartNew(function: Func&lt;&#39;TResult&gt;, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler) : Task&lt;&#39;TResult&gt;<br />TaskFactory.StartNew(function: Func&lt;obj,&#39;TResult&gt;, state: obj, cancellationToken: CancellationToken, creationOptions: TaskCreationOptions, scheduler: TaskScheduler) : Task&lt;&#39;TResult&gt;</div>
<div class="tip" id="fs26">static member Async.AwaitTask : task:Task&lt;&#39;T&gt; -&gt; Async&lt;&#39;T&gt;</div>
<div class="tip" id="fs27">val fooAsync : unit -&gt; Async&lt;unit&gt;<br /><br />Full name: Csharp-async-gotchas.aspx_.fooAsync</div>
<div class="tip" id="fs28">val handler : unit -&gt; unit<br /><br />Full name: Csharp-async-gotchas.aspx_.handler</div>
<div class="tip" id="fs29">static member Async.RunSynchronously : computation:Async&lt;&#39;T&gt; * ?timeout:int * ?cancellationToken:CancellationToken -&gt; &#39;T</div>


<div class="row">
	<div class="small-4 columns">&#160;</div>
  <div class="small-8 columns">

<!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style addthis_16x16_style">
<a class="addthis_button_twitter"></a>
<a class="addthis_button_reddit"></a>
<a class="addthis_button_google_plusone_share"></a>
<a class="addthis_button_hackernews"></a>
<a class="addthis_button_facebook"></a>
<a class="addthis_button_compact"></a><a class="addthis_counter addthis_bubble_style"></a>
</div>
<script type="text/javascript">var addthis_config = { "data_track_addressbar": false };</script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-521c32162e6001a0"></script>
<!-- AddThis Button END -->

<p class="post-meta">
  <span><strong>Published</strong>: Monday, 15 April 2013, 4:00 AM</span><br />      
  <span class="tags"><strong>Tags</strong>: async, c#, f#</span>
</p>

  </div>
</div>

    </content>

  </div>
  <div class="large-4 columns" id="right-bar">
    <div class="right-item" id="right-calendar">
      <script type="text/javascript">
        var monthNames =
          ["January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"];
        var d = new Date();
        var m = monthNames[d.getMonth()];
        var y = d.getFullYear();
        var ml = m.toLowerCase();
        document.writeln("<h4>Calendar - " + m + " " + y + "</h4>");
        document.writeln("<a href=\"http://tomasp.net/calendar/" + y + "/" + ml + ".html\">" +
          "<img src=\"http://tomasp.net/calendar/" + y + "/" + ml + "-preview.jpg\" style=\"border-style:none;\" />" +
          "</a>");
      </script> 
      <p>The calendar shows a new picture each month since 
        <a href="http://tomasp.net/calendar/2005">2005</a>, <a href="http://tomasp.net/calendar/2006">2006</a>, 
        <a href="http://tomasp.net/calendar/2007">2007</a>, <a href="http://tomasp.net/calendar/2008">2008</a>, 
        <a href="http://tomasp.net/calendar/2009">2009</a>, <a href="http://tomasp.net/calendar/2010">2010</a>, 
        <a href="http://tomasp.net/calendar/2011">2011</a>, <a href="http://tomasp.net/calendar/2012">2012</a>. <br />
        See the first photos of <a href="http://tomasp.net/calendar/2013">2013</a>.
      </p>
    </div>

    <h3>Welcome!</h3>
    <img src="http://tomasp.net/img/tomas.jpg" alt="Tomas Petricek" style="float:right;margin:10px 0px 10px 10px;" />
    <p>I'm an F# enthusiast, book author and a PhD student at the University of Cambridge.
      When offline, I enjoy traveling and taking pictures. You can find me at
      at <a href="http://twitter.com/tomaspetricek">@tomaspetricek</a> or email 
      <a href="mailto:tomas@tomasp.net">tomas@tomasp.net</a>.
    </p>

    <script type="text/javascript" src="http://tomasp.net/news/news.js"></script>
    <h4>What's new? &#160; <small><script type="text/javascript">document.write(news.date)</script></small></h4>
    <script>
      document.write(news.info);
    </script>

    <h4>Trainings and consulting</h4>
    <img src="http://tomasp.net/img/skillsmatter.png" alt="Tomas Petricek" style="float:right;margin:15px 0px 10px 10px;" />
    <p>I run F# and functional programming courses in <strong>London</strong>
      and <strong>New York</strong> with SkillsMatter.
    </p>
    <ul>
      <li>Check out our <a href="http://skillsmatter.com/course/scala/tomas-petricek-phil-trelford-fast-track-to-fsharp/ps-6679">Fast Track to F#</a> course</li>
      <li><a href="mailto:tomas@tomasp.net">Email me</a> for info about private trainings</li>
    </ul>
    
    <h4>F# Books and articles</h4>
    <div style="float:right;">
      <a href="http://www.amazon.com/gp/product/1933988924/ref=as_li_tf_il?ie=UTF8&amp;tag=httptomasnet-20&amp;linkCode=as2&amp;camp=217145&amp;creative=399369&amp;creativeASIN=1933988924">
        <img src="http://tomasp.net/img/rwfp.jpg" alt="Real World Functional Programming" style="float:right;margin:10px 0px 10px 10px;border-style:none;" />
      </a>
    </div>
    <p><a href="http://www.manning.com/petricek">Real World Functional Programming</a> explains functional
      concepts using F# and C#. You can get it from <a href="http://www.amazon.com/dp/1933988924?tag=httptomasnet-20&amp;camp=213381&amp;creative=390973&amp;linkCode=as4&amp;creativeASIN=1933988924&amp;adid=0F1DP260JGG4KY0CDGP6">Amazon.com</a>, <a href="https://www.amazon.co.uk/dp/1933988924?tag=tomasnet-21&amp;camp=1406&amp;creative=6394&amp;linkCode=as1&amp;creativeASIN=1933988924&amp;adid=1CTY87YCCQEJW965GNDF">Amazon.co.uk</a> or your favorite book store.
      Some chapters and new materials are also available on <a href="http://msdn.microsoft.com/en-us/library/hh314518.aspx">MSDN</a>.</p>
    
    <p>Currently, I'm putting together <a href="http://www.manning.com/petricek2/">F# Deep Dives</a> - a collection
      of practical F# essays written by community leaders and commercial users of F#.</p>
    <p>I also wrote a series of tutorials on <a href="http://www.tryfsharp.org/Learn/financial-computing">financial computing</a>
      for Try F# - an interactive environment that let's you try F# in the browser.</p>

    <h4>Research and teaching</h4>
    <img src="http://tomasp.net/img/cam.png" alt="University of Cambride" style="float:right;margin:25px 0px 10px 10px;" />
    <p>I'm finishing PhD in computer science at the <a href="http://www.cl.cam.ac.uk/">University of Cambridge</a>.
      I'm working on making better types for programs that run in rich context (like F# type providers, distributed 
      prog&shy;ramming or data-flow). See <a href="http://www.cl.cam.ac.uk/~tp322/">my academic page</a> for
      more.</p>

    <h4>Blog tags</h4>
    <p>

      <a href="http://tomasp.net/blog/tag/fsharp/">f#</a>&nbsp;(86),       <a href="http://tomasp.net/blog/tag/functional/">functional</a>&nbsp;(63),       <a href="http://tomasp.net/blog/tag/research/">research</a>&nbsp;(25),       <a href="http://tomasp.net/blog/tag/writing/">writing</a>&nbsp;(11),       <a href="http://tomasp.net/blog/tag/csharp/">c#</a>&nbsp;(29),       <a href="http://tomasp.net/blog/tag/links/">links</a>&nbsp;(15),       <a href="http://tomasp.net/blog/tag/presentations/">presentations</a>&nbsp;(14),       <a href="http://tomasp.net/blog/tag/haskell/">haskell</a>&nbsp;(6),       <a href="http://tomasp.net/blog/tag/talks/">talks</a>&nbsp;(2),       <a href="http://tomasp.net/blog/tag/new-york/">new york</a>&nbsp;(2),       <a href="http://tomasp.net/blog/tag/manning/">manning</a>&nbsp;(2),       <a href="http://tomasp.net/blog/tag/books/">books</a>&nbsp;(2),       <a href="http://tomasp.net/blog/tag/open-source/">open source</a>&nbsp;(2),       <a href="http://tomasp.net/blog/tag/training/">training</a>&nbsp;(1),       <a href="http://tomasp.net/blog/tag/deep-dives/">deep dives</a>&nbsp;(1),       <a href="http://tomasp.net/blog/tag/functional-programming/">functional programming</a>&nbsp;(1),       <a href="http://tomasp.net/blog/tag/async/">async</a>&nbsp;(1),       <a href="http://tomasp.net/blog/tag/fsharp-data/">f# data</a>&nbsp;(1),       <a href="http://tomasp.net/blog/tag/type-providers/">type providers</a>&nbsp;(1),       <a href="http://tomasp.net/blog/tag/events/">events</a>&nbsp;(1)    </p>

  </div>
</div>


  <div class="row" id="footer">
  <footer>   
    <div class="large-3 columns">
      <h4>Contact &amp; about</h4>
      <p>This site is hosted on GitHub and is generated using <a href="https://github.com/tpetricek/FSharp.Formatting">F# Formatting</a>.
        For more info, see the <a href="https://github.com/tpetricek/TomaspNet.Website">website source on GitHub</a>.
      </p>
      <p>Please submit issues &amp; corrections on GitHub. Use pull requests for minor corrections only.</p>
      <ul>
        <li>Email me: <a href="mailto:tomas@tomasp.net">tomas@tomasp.net</a></li>
        <li>Connect via Twitter: <a href="http://twitter.com/tomaspetricek">@tomaspetricek</a></li>
        <li>More: <a href="http://uk.linkedin.com/in/tomaspetricek">LinkedIn</a> | <a href="http://lanyrd.com/profile/tomasp/">Lanyrd</a> | <a href="https://github.com/tpetricek">GitHub</a></li>
      </ul>
    </div>
    <div class="large-7 columns">
    <h4>Blog archives <a href="http://tomasp.net/rss.xml"><img src="http://tomasp.net/img/rss.gif" /></a></h4>
      <a href="http://tomasp.net/blog/archive/august-2013/index.html">
        August 2013 (2)</a>,      <a href="http://tomasp.net/blog/archive/may-2013/index.html">
        May 2013 (1)</a>,      <a href="http://tomasp.net/blog/archive/april-2013/index.html">
        April 2013 (1)</a>,      <a href="http://tomasp.net/blog/archive/march-2013/index.html">
        March 2013 (1)</a>,      <a href="http://tomasp.net/blog/archive/february-2013/index.html">
        February 2013 (1)</a>,      <a href="http://tomasp.net/blog/archive/january-2013/index.html">
        January 2013 (1)</a>,      <a href="http://tomasp.net/blog/archive/december-2012/index.html">
        December 2012 (2)</a>,      <a href="http://tomasp.net/blog/archive/october-2012/index.html">
        October 2012 (1)</a>,      <a href="http://tomasp.net/blog/archive/august-2012/index.html">
        August 2012 (3)</a>,      <a href="http://tomasp.net/blog/archive/june-2012/index.html">
        June 2012 (2)</a>,      <a href="http://tomasp.net/blog/archive/april-2012/index.html">
        April 2012 (1)</a>,      <a href="http://tomasp.net/blog/archive/march-2012/index.html">
        March 2012 (4)</a>,      <a href="http://tomasp.net/blog/archive/february-2012/index.html">
        February 2012 (5)</a>,      <a href="http://tomasp.net/blog/archive/january-2012/index.html">
        January 2012 (2)</a>,      <a href="http://tomasp.net/blog/archive/november-2011/index.html">
        November 2011 (5)</a>,      <a href="http://tomasp.net/blog/archive/august-2011/index.html">
        August 2011 (3)</a>,      <a href="http://tomasp.net/blog/archive/july-2011/index.html">
        July 2011 (2)</a>,      <a href="http://tomasp.net/blog/archive/june-2011/index.html">
        June 2011 (2)</a>,      <a href="http://tomasp.net/blog/archive/may-2011/index.html">
        May 2011 (2)</a>,      <a href="http://tomasp.net/blog/archive/march-2011/index.html">
        March 2011 (4)</a>,      <a href="http://tomasp.net/blog/archive/december-2010/index.html">
        December 2010 (1)</a>,      <a href="http://tomasp.net/blog/archive/november-2010/index.html">
        November 2010 (6)</a>,      <a href="http://tomasp.net/blog/archive/october-2010/index.html">
        October 2010 (6)</a>,      <a href="http://tomasp.net/blog/archive/september-2010/index.html">
        September 2010 (4)</a>,      <a href="http://tomasp.net/blog/archive/july-2010/index.html">
        July 2010 (3)</a>,      <a href="http://tomasp.net/blog/archive/june-2010/index.html">
        June 2010 (2)</a>,      <a href="http://tomasp.net/blog/archive/may-2010/index.html">
        May 2010 (1)</a>,      <a href="http://tomasp.net/blog/archive/february-2010/index.html">
        February 2010 (2)</a>,      <a href="http://tomasp.net/blog/archive/january-2010/index.html">
        January 2010 (3)</a>,      <a href="http://tomasp.net/blog/archive/december-2009/index.html">
        December 2009 (3)</a>,      <a href="http://tomasp.net/blog/archive/july-2009/index.html">
        July 2009 (1)</a>,      <a href="http://tomasp.net/blog/archive/june-2009/index.html">
        June 2009 (3)</a>,      <a href="http://tomasp.net/blog/archive/may-2009/index.html">
        May 2009 (2)</a>,      <a href="http://tomasp.net/blog/archive/april-2009/index.html">
        April 2009 (1)</a>,      <a href="http://tomasp.net/blog/archive/march-2009/index.html">
        March 2009 (2)</a>,      <a href="http://tomasp.net/blog/archive/february-2009/index.html">
        February 2009 (1)</a>,      <a href="http://tomasp.net/blog/archive/december-2008/index.html">
        December 2008 (1)</a>,      <a href="http://tomasp.net/blog/archive/november-2008/index.html">
        November 2008 (5)</a>,      <a href="http://tomasp.net/blog/archive/october-2008/index.html">
        October 2008 (1)</a>,      <a href="http://tomasp.net/blog/archive/september-2008/index.html">
        September 2008 (1)</a>,      <a href="http://tomasp.net/blog/archive/june-2008/index.html">
        June 2008 (1)</a>,      <a href="http://tomasp.net/blog/archive/march-2008/index.html">
        March 2008 (3)</a>,      <a href="http://tomasp.net/blog/archive/february-2008/index.html">
        February 2008 (1)</a>,      <a href="http://tomasp.net/blog/archive/december-2007/index.html">
        December 2007 (2)</a>,      <a href="http://tomasp.net/blog/archive/november-2007/index.html">
        November 2007 (6)</a>,      <a href="http://tomasp.net/blog/archive/october-2007/index.html">
        October 2007 (1)</a>,      <a href="http://tomasp.net/blog/archive/september-2007/index.html">
        September 2007 (1)</a>,      <a href="http://tomasp.net/blog/archive/august-2007/index.html">
        August 2007 (1)</a>,      <a href="http://tomasp.net/blog/archive/july-2007/index.html">
        July 2007 (2)</a>,      <a href="http://tomasp.net/blog/archive/april-2007/index.html">
        April 2007 (2)</a>,      <a href="http://tomasp.net/blog/archive/march-2007/index.html">
        March 2007 (3)</a>,      <a href="http://tomasp.net/blog/archive/february-2007/index.html">
        February 2007 (3)</a>,      <a href="http://tomasp.net/blog/archive/january-2007/index.html">
        January 2007 (2)</a>,      <a href="http://tomasp.net/blog/archive/november-2006/index.html">
        November 2006 (1)</a>,      <a href="http://tomasp.net/blog/archive/october-2006/index.html">
        October 2006 (3)</a>,      <a href="http://tomasp.net/blog/archive/august-2006/index.html">
        August 2006 (2)</a>,      <a href="http://tomasp.net/blog/archive/july-2006/index.html">
        July 2006 (1)</a>,      <a href="http://tomasp.net/blog/archive/june-2006/index.html">
        June 2006 (3)</a>,      <a href="http://tomasp.net/blog/archive/may-2006/index.html">
        May 2006 (2)</a>,      <a href="http://tomasp.net/blog/archive/april-2006/index.html">
        April 2006 (2)</a>,      <a href="http://tomasp.net/blog/archive/december-2005/index.html">
        December 2005 (1)</a>,      <a href="http://tomasp.net/blog/archive/july-2005/index.html">
        July 2005 (4)</a>,      <a href="http://tomasp.net/blog/archive/june-2005/index.html">
        June 2005 (5)</a>,      <a href="http://tomasp.net/blog/archive/may-2005/index.html">
        May 2005 (1)</a>,      <a href="http://tomasp.net/blog/archive/april-2005/index.html">
        April 2005 (3)</a>,      <a href="http://tomasp.net/blog/archive/march-2005/index.html">
        March 2005 (3)</a>,      <a href="http://tomasp.net/blog/archive/january-2005/index.html">
        January 2005 (1)</a>,      <a href="http://tomasp.net/blog/archive/december-2004/index.html">
        December 2004 (3)</a>,      <a href="http://tomasp.net/blog/archive/november-2004/index.html">
        November 2004 (2)</a>,    </div>
    <div class="large-2 columns">
      <h4>License</h4>
      <p>Unless explicitly mentioned, all articles on this site are licensed under <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution Share Alike</a>. 
        All source code samples are licensed under Apache 2.0.
      </p>
      <img src="http://tomasp.net/img/cc-sa.png" alt="CC License logo" />
    </div>
  </footer>
  </div>
  
  <script>
  document.write('<script src=' +
  ('__proto__' in {} ? 'http://tomasp.net/js/vendor/zepto' : 'http://tomasp.net/js/vendor/jquery') +
  '.js><\/script>')
  </script>
  
  <script src="http://tomasp.net/js/foundation.min.js"></script>
  <script>
    $(document).foundation();
  </script>
  <script type="text/javascript">

    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-1561220-1']);
    _gaq.push(['_trackPageview']);

    (function () {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

  </script>
</body>
</html>